#   Copyright (c)  2020, CardioPipeLine
#   Author: Rohit Suratekar
#   Organization: IIMCB
#
# Salmon pipeline

import os
import subprocess

from helpers import ConfigParser, MetaParser, make_path, exists_path
from pipelines._base_pipe import PipeLine


class Salmon(PipeLine):
    def __init__(self, config: ConfigParser,
                 meta: MetaParser,
                 force_index: bool = False):
        super().__init__()
        self.config = config
        self.meta = meta
        self.sra = meta.sra
        self.force_index = force_index

        out_folder = f"{self.config.names.sra.folder(self.sra)}/salmon"
        self.config.tools.salmon.output_folder = out_folder
        make_path(out_folder)
        self.log.info(f"Salmon output folder set to {out_folder}")

        self.log.info("Salmon Pipeline Initialized")

    def generate_decoy(self):
        self.log.info("Salmon generating decoy files")
        index_folder = self.config.tools.salmon.index
        make_path(index_folder)  # Sanity check

        decoy_script = "external/generateDecoyTranscriptome.sh"

        # Check if binary has proper access to execute the command
        if not os.access(decoy_script, os.X_OK):
            self._log.error(f"Script {decoy_script} do not "
                            f"have permission to execute.",
                            exception=PermissionError)

        opts = [
            decoy_script,  # Path to decoy script
            "-j",  # Number of threads
            str(self.config.no_of_threads),
            # If unknown, keep 1 or remove option
            "-a",  # GTF genome annotation
            self.config.names.genome.gtf,
            "-g",  # Genome in fasta
            self.config.names.genome.fasta,
            "-t",  # Transcriptom from cDNA in fasta
            self.config.names.genome.transcript,
            "-o",  # Output path
            index_folder,  # Keep in index folder itself
            "-b",  # Path to bedtools binary
            self.config.tools.bedtools.path,
            "-m",  # Path to mashmap binary
            self.config.tools.mashmap.path
        ]

        if subprocess.run(opts, shell=True).returncode == 0:
            self.log.info(
                f"Salmon Decoy file generated successfully in {index_folder}")
        else:
            self.log.error("Something went wrong while generating decoy "
                           "files for Salmon")

    def index_salmon(self):
        self.log.info("Checking if Salmon index exists")
        index_folder = self.config.tools.salmon.index
        make_path(index_folder)
        # Check if folder is empty
        # Greater than 2 because those can be decoy files which are
        # generated before indexing
        if len(os.listdir(index_folder)) > 2 and not self.force_index:
            self.log.info(f"Salmon index folder is non empty and assuming "
                          f"indexing has already done. "
                          f"Index folder : {index_folder}")
            self.log.info("If you want to re-index, please pass "
                          "'force_index=True' in the class argument")
            return

        decoy_index = self.config.tools.salmon.get_extra("decoy_index")
        decoy_keys = self.config.tools.salmon.get_extra("decoy_keys")
        if not exists_path(decoy_index):
            self.generate_decoy()

        # Note :
        # Use decoy index generated by above function instead of original
        # transcript for indexing
        # Relevant information is on following tutorial
        # https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment/

        opts = [
            "index",  # Index mode
            "-t",  # Decoy transcript path (Read above note)
            decoy_index,
            "-i",  # Index folder
            index_folder,
            "--decoys",  # Point to Decoy Text file
            decoy_keys,
            "-k",  # k-mer length.
            str(31),  # 31 is default and recommended by the authors
            "-p",  # Number of threads
            str(self.config.no_of_threads)  # If unknown, don't use it
        ]

        # Start indexing
        self.log.info("Salmon indexing started")
        self.config.tools.salmon.run(opts,
                                     success="Salmon indexing is "
                                             "successfully finished")

    def _check_if_done(self):
        # Checks if analysis is already done.
        return exists_path(
            f"{self.config.tools.salmon.output_folder}/quant.sf")

    def _single_end(self, srr: str, in_opts: list):

        # for the metadata
        data = self.meta.data

        self.log.info(f"Assuming {srr} is a single end sample")
        # Make a copy of the options so that it can be used later if needed
        opts = [x for x in in_opts]

        files = self.fasta_for_analysis(srr)

        # Sanity check
        if len(files) != 1:
            self.log.error(f"{srr} has {len(files)} reads. This pipeline "
                           f"currently only handles single or paired end",
                           exception=TypeError)

        # Add single end file
        opts.append("-r")
        opts.append(files[0])

        data[srr][self.meta.key_salmon] = {
            "analysis": "Single End",
            "input": files,
            "index": self.config.tools.salmon.index,
            "output": self.config.tools.salmon.output_folder
        }

        self.log.info("Starting single end Salmon quantification")
        self.config.tools.salmon.run(opts,
                                     success=f"Salmon quantification for "
                                             f"{srr} is successful")

        self.meta.append(data)

    def _paired_end(self, srr: str, in_opts: list):

        # for the metadata
        data = self.meta.data

        self.log.info(f"Assuming {srr} is a paired end sample")
        # Make a copy of the options so that it can be used later if needed
        files = []
        opts = [x for x in in_opts]
        for i, f in enumerate(self.fasta_for_analysis(srr)):
            opts.append(str(-(i + 1)))
            opts.append(f)
            files.append(f)

        data[srr][self.meta.key_salmon] = {
            "analysis": "Paired End",
            "input": files,
            "index": self.config.tools.salmon.index,
            "output": self.config.tools.salmon.output_folder
        }

        self.log.info("Starting pair end Salmon quantification")
        self.config.tools.salmon.run(opts,
                                     success=f"Salmon quantification for "
                                             f"{srr} is successful")

        self.meta.append(data)

    def quant_salmon(self):

        if self._check_if_done():
            self.log.info(f"Salmon quantification is already done for sra "
                          f"{self.sra}")
            return
        self.log.info(f"Salmon quantification for {self.sra}")

        opts = [
            "quant",  # Quant mode
            "-i",  # Index path
            self.config.tools.salmon.index,
            "-l",  # Library type
            "A",  # Automatic
            "--validateMapping",
            # enables selective alignment of the sequencing reads
            "--gcBias",  # Corrects for  fragment-level GC biases. This option
            # is also recommended by DESeq2 analysis
            "-p",  # Number of threads
            str(self.config.no_of_threads),  # Remove this option if not sure
            "-g",  # Additional GTF file to get quants.genes.sf
            self.config.names.genome.gtf,
            "-o",  # Output path
            self.config.tools.salmon.output_folder
        ]

        for srr in self.meta.get_runs():
            if self.meta.is_paired_end(srr):
                self._paired_end(srr, opts)
            else:
                self._single_end(srr, opts)

    def run(self):
        self.index_salmon()
        self.quant_salmon()

        self.log.info("Exiting Salon pipeline")
